<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="StarryX-Record"><title>starry - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-c579a84d.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="starry" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (6067b3631 2025-01-17)" data-channel="nightly" data-search-js="search-ccb196c1.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../starry/index.html">starry</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#starryx-record" title="StarryX-Record">StarryX-Record</a><ul><li><a href="#è¿›ç¨‹ç®¡ç†" title="è¿›ç¨‹ç®¡ç†">è¿›ç¨‹ç®¡ç†</a></li><li><a href="#ä¿¡å·æœºåˆ¶" title="ä¿¡å·æœºåˆ¶">ä¿¡å·æœºåˆ¶</a></li><li><a href="#futex" title="Futex">Futex</a></li><li><a href="#arceos-change" title="ArceOS change">ArceOS change</a></li><li><a href="#questions" title="Questions">Questions</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>starry</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/starry/main.rs.html#1-35">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="starryx-record"><a class="doc-anchor" href="#starryx-record">Â§</a>StarryX-Record</h2>
<p>å¯åŠ¨æµç¨‹ _start(axhal) -&gt; rust_entry(axhal) -&gt; rust_main(axruntime) -&gt; main(starry) -&gt; run_user_app</p>
<p>run_user_app major process</p>
<ol>
<li>è¿›å…¥æ‰§è¡Œç¨‹åºç›®å½•</li>
<li>åŠ è½½ç”¨æˆ·elfæ–‡ä»¶</li>
<li>åˆå§‹åŒ–ç”¨æˆ·ä¸Šä¸‹æ–‡</li>
<li>åˆ›å»ºç”¨æˆ·ä»»åŠ¡å’Œçº¿ç¨‹æ•°æ®</li>
<li>å¤åˆ¶å…¨å±€å‘½åç©ºé—´æ•°æ®åˆ°æœ¬åœ°çº¿ç¨‹ç©ºé—´</li>
<li>åˆ›å»ºè¿›ç¨‹å’Œçº¿ç¨‹</li>
<li>é˜»å¡ä¸»ä»»åŠ¡å¹¶è°ƒåº¦</li>
</ol>
<h3 id="è¿›ç¨‹ç®¡ç†"><a class="doc-anchor" href="#è¿›ç¨‹ç®¡ç†">Â§</a>è¿›ç¨‹ç®¡ç†</h3><h4 id="æ•°æ®ç»“æ„"><a class="doc-anchor" href="#æ•°æ®ç»“æ„">Â§</a>æ•°æ®ç»“æ„</h4><div class="example-wrap"><pre class="language-mermaid"><code>graph TD
    subgraph &quot;Task å±‚ (åŸºç¡€è°ƒåº¦å•å…ƒ)&quot;
        Task[&quot;Task/TaskInner
        - id: TaskId
        - name: String
        - state: TaskState
        - ctx: TaskContext
        - kstack: TaskStack
        - task_ext: AxTaskExt&quot;]
    end
    
    subgraph &quot;Taskæ‰©å±•å±‚ (è¿æ¥Taskå’ŒThread)&quot;
        TaskExt[&quot;TaskExt
        - time: TimeStat
        - thread: Arc&lt;Thread&gt;&quot;]
    end
    
    subgraph &quot;Thread å±‚ (çº¿ç¨‹)&quot;
        Thread[&quot;Thread
        - tid: Pid
        - process: Arc&lt;Process&gt;
        - data: Box&lt;dyn Any&gt;&quot;]
        
        ThreadData[&quot;ThreadData
        - clear_child_tid: AtomicUsize&quot;]
    end
    
    subgraph &quot;Process å±‚ (è¿›ç¨‹)&quot;
        Process[&quot;Process
        - pid: Pid
        - is_zombie: AtomicBool
        - tg: ThreadGroup
        - data: Box&lt;dyn Any&gt;
        - children: StrongMap&lt;Pid, Arc&lt;Process&gt;&gt;
        - parent: Weak&lt;Process&gt;
        - group: Arc&lt;ProcessGroup&gt;&quot;]
        
        ProcessData[&quot;ProcessData
        - exe_path: String
        - aspace: Arc&lt;Mutex&lt;AddrSpace&gt;&gt;
        - ns: AxNamespace
        - heap_bottom/top: AtomicUsize&quot;]
        
        ThreadGroup[&quot;ThreadGroup
        - threads: WeakMap&lt;Pid, Weak&lt;Thread&gt;&gt;
        - exit_code: i32
        - group_exited: bool&quot;]
        
        ProcessGroup[&quot;ProcessGroup
        - pgid: Pid
        - session: Arc&lt;Session&gt;
        - processes: WeakMap&lt;Pid, Weak&lt;Process&gt;&gt;&quot;]
        
        Session[&quot;Session
        - sid: Pid
        - process_groups: WeakMap&lt;Pid, Weak&lt;ProcessGroup&gt;&gt;&quot;]
    end
    
    %% è¿æ¥å…³ç³»
    Task --&gt;|æ‹¥æœ‰| TaskExt
    TaskExt --&gt;|å¼•ç”¨| Thread
    Thread --&gt;|å±äº| Process
    Thread --&gt;|æ‹¥æœ‰| ThreadData
    Process --&gt;|æ‹¥æœ‰| ProcessData
    Process --&gt;|ç®¡ç†| ThreadGroup
    ThreadGroup --&gt;|åŒ…å«| Thread
    Process --&gt;|å½’å±äº| ProcessGroup
    ProcessGroup --&gt;|å½’å±äº| Session
    Process --&gt;|å­è¿›ç¨‹å…³ç³»| Process</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>axprocess::Process::new_init(axtask::current().id().as_u64() <span class="kw">as _</span>).build();</code></pre></div>
<p>ç›¸å…³æ•°æ®ç»“æ„</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// A builder for creating a new [`Process`].
</span><span class="kw">pub struct </span>ProcessBuilder {
    pid: Pid,
    parent: <span class="prelude-ty">Option</span>&lt;Arc&lt;Process&gt;&gt;,
    data: Box&lt;<span class="kw">dyn </span>Any + Send + Sync&gt;,
}

<span class="doccomment">/// A process.
</span><span class="kw">pub struct </span>Process {
    pid: Pid,
    is_zombie: AtomicBool,
    <span class="kw">pub</span>(<span class="kw">crate</span>) tg: SpinNoIrq&lt;ThreadGroup&gt;,

    data: Box&lt;<span class="kw">dyn </span>Any + Send + Sync&gt;,

    <span class="comment">// TODO: child subreaper
    </span>children: SpinNoIrq&lt;StrongMap&lt;Pid, Arc&lt;Process&gt;&gt;&gt;,
    parent: SpinNoIrq&lt;Weak&lt;Process&gt;&gt;,

    group: SpinNoIrq&lt;Arc&lt;ProcessGroup&gt;&gt;,
}

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct </span>ThreadGroup {
    <span class="kw">pub</span>(<span class="kw">crate</span>) threads: WeakMap&lt;Pid, Weak&lt;Thread&gt;&gt;,
    <span class="kw">pub</span>(<span class="kw">crate</span>) exit_code: i32,
    <span class="kw">pub</span>(<span class="kw">crate</span>) group_exited: bool,
}

<span class="doccomment">/// A [`ProcessGroup`] is a collection of [`Process`]es.
</span><span class="kw">pub struct </span>ProcessGroup {
    pgid: Pid,
    <span class="kw">pub</span>(<span class="kw">crate</span>) session: Arc&lt;Session&gt;,
    <span class="kw">pub</span>(<span class="kw">crate</span>) processes: SpinNoIrq&lt;WeakMap&lt;Pid, Weak&lt;Process&gt;&gt;&gt;,
}

<span class="doccomment">/// A [`Session`] is a collection of [`ProcessGroup`]s.
</span><span class="kw">pub struct </span>Session {
    sid: Pid,
    <span class="kw">pub</span>(<span class="kw">crate</span>) process_groups: SpinNoIrq&lt;WeakMap&lt;Pid, Weak&lt;ProcessGroup&gt;&gt;&gt;,
    <span class="comment">// TODO: shell job control
</span>}</code></pre></div>
<h4 id="èµ„æºé™åˆ¶"><a class="doc-anchor" href="#èµ„æºé™åˆ¶">Â§</a>èµ„æºé™åˆ¶</h4><h3 id="ä¿¡å·æœºåˆ¶"><a class="doc-anchor" href="#ä¿¡å·æœºåˆ¶">Â§</a>ä¿¡å·æœºåˆ¶</h3><div class="example-wrap"><pre class="language-mermaid"><code>classDiagram
    class Signo {
        +SIGHUP, SIGINT, SIGKILL, etc.
        +is_realtime() bool
        +default_action() DefaultSignalAction
    }
    
    class DefaultSignalAction {
        &lt;&lt;enumeration&gt;&gt;
        Terminate
        Ignore
        CoreDump
        Stop
        Continue
    }
    
    class SignalOSAction {
        &lt;&lt;enumeration&gt;&gt;
        Terminate
        CoreDump
        Stop
        Continue
        Handler
    }
    
    class SignalSet {
        -u64 value
        +add(signal: Signo) bool
        +remove(signal: Signo) bool
        +has(signal: Signo) bool
        +dequeue(mask: SignalSet) Option~Signo~
        +to_ctype(dest: kernel_sigset_t)
    }
    
    class SignalInfo {
        -siginfo_t raw_info
        +new(signo: Signo, code: u32)
        +signo() Signo
        +set_signo(signo: Signo)
        +code() u32
        +set_code(code: u32)
    }
    
    class SignalActionFlags {
        &lt;&lt;bitflags&gt;&gt;
        +SIGINFO
        +NODEFER
        +RESETHAND
        +RESTART
        +ONSTACK
        +RESTORER
    }
    
    class SignalDisposition {
        &lt;&lt;enumeration&gt;&gt;
        Default
        Ignore
        Handler
    }
    
    class SignalAction {
        +flags: SignalActionFlags
        +mask: SignalSet
        +disposition: SignalDisposition
        +restorer: __sigrestore_t
        +to_ctype(dest: kernel_sigaction)
    }
    
    class SignalStack {
        +sp: usize
        +flags: u32
        +size: usize
        +disabled() bool
    }
    
    class PendingSignals {
        +set: SignalSet
        -info_std: [Option~SignalInfo~; 32]
        -info_rt: [VecDeque~SignalInfo~; 33]
        +new()
        +put_signal(sig: SignalInfo) bool
        +dequeue_signal(mask: SignalSet) Option~SignalInfo~
    }
    
    Signo --&gt; DefaultSignalAction: defines default action
    SignalDisposition --&gt; Signo: references for handlers
    SignalInfo --&gt; Signo: contains signal number
    SignalSet --&gt; Signo: manages set of signals
    SignalAction --&gt; SignalDisposition: defines action
    SignalAction --&gt; SignalSet: holds blocked signals
    SignalAction --&gt; SignalActionFlags: configures behavior
    PendingSignals --&gt; SignalSet: tracks pending signals
    PendingSignals --&gt; SignalInfo: stores signal info
```
</code></pre></div><h4 id="æ³¨å†Œä¿¡å·"><a class="doc-anchor" href="#æ³¨å†Œä¿¡å·">Â§</a>æ³¨å†Œä¿¡å·</h4><h5 id="linux"><a class="doc-anchor" href="#linux">Â§</a>Linux</h5><div class="example-wrap"><pre class="language-c"><code>struct sigaction {
#ifndef __ARCH_HAS_IRIX_SIGACTION (mips define)
	__sighandler_t	sa_handler;
	unsigned long	sa_flags;
#else
	unsigned int	sa_flags;
	__sighandler_t	sa_handler;
#endif
#ifdef __ARCH_HAS_SA_RESTORER (x86)
	__sigrestore_t sa_restorer;
#endif
	sigset_t	sa_mask;	/* mask last for extensibility */
};

struct k_sigaction {
	struct sigaction sa;
#ifdef __ARCH_HAS_KA_RESTORER
	__sigrestore_t ka_restorer;
#endif
};

SYSCALL_DEFINE4(rt_sigaction, int, sig,
    const struct sigaction __user *, act,
    struct sigaction __user *, oact,
    size_t, sigsetsize)
{
    struct k_sigaction new_sa, old_sa;
    int ret = -EINVAL;
......
    if (act) {
      if (copy_from_user(&amp;new_sa.sa, act, sizeof(new_sa.sa)))
        return -EFAULT;
    }

    ret = do_sigaction(sig, act ? &amp;new_sa : NULL, oact ? &amp;old_sa : NULL);

    if (!ret &amp;&amp; oact) {
        if (copy_to_user(oact, &amp;old_sa.sa, sizeof(old_sa.sa)))
            return -EFAULT;
    }
out:
    return ret;
}

int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
{
    struct task_struct *p = current, *t;
    struct k_sigaction *k;
    sigset_t mask;
......
    k = &amp;p-&gt;sighand-&gt;action[sig-1];

    spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);
    if (oact)
        *oact = *k;

    if (act) {
        sigdelsetmask(&amp;act-&gt;sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));
        *k = *act;
......
  }

  spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);
  return 0;
}</code></pre></div><h4 id="å‘é€ä¿¡å·"><a class="doc-anchor" href="#å‘é€ä¿¡å·">Â§</a>å‘é€ä¿¡å·</h4><h4 id="linux-1"><a class="doc-anchor" href="#linux-1">Â§</a>Linux</h4><div class="example-wrap"><pre class="language-c"><code>// kernel/signal.c
SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
{
    struct kernel_siginfo info;

    // åˆå§‹åŒ–ä¿¡å·ä¿¡æ¯ç»“æ„ä½“
    clear_siginfo(&amp;info);
    info.si_signo = sig;
    info.si_errno = 0;
    info.si_code = SI_USER;  // æ¥è‡ªç”¨æˆ·ç©ºé—´çš„ä¿¡å·
    info.si_pid = task_tgid_vnr(current); // å‘é€è€… PID
    info.si_uid = from_kuid_munged(current_user_ns(), current_uid());

    // æ ¸å¿ƒå¤„ç†å‡½æ•°
    return kill_something_info(sig, &amp;info, pid);
}

static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)
{
    if (pid &gt; 0) {
        // å‘é€ç»™å•ä¸ªè¿›ç¨‹
        return kill_pid_info(sig, info, find_vpid(pid));
    } else if (pid == -1) {
        // å¹¿æ’­ç»™æ‰€æœ‰æœ‰æƒé™çš„è¿›ç¨‹
        int ret = __kill_pgrp_info(sig, info, task_pgrp(current));
        // ... å…¶ä»–è¿›ç¨‹ç»„å¤„ç†
    } else if (pid &lt; 0) {
        // å‘é€ç»™è¿›ç¨‹ç»„ |pid|
        return kill_pgrp_info(sig, info, pid);
    } else if (pid == 0) {
        // å½“å‰è¿›ç¨‹ç»„
        return kill_pgrp_info(sig, info, task_pgrp(current));
    }
    return -EINVAL;
}

// kernel/signal.c
static int check_kill_permission(int sig, struct kernel_siginfo *info,
                                 struct task_struct *t)
{
    const struct cred *cred = current_cred();
    const struct cred *tcred = __task_cred(t);

    // ç‰¹æƒè¿›ç¨‹ (CAP_KILL) å¯ä»¥ç»•è¿‡æƒé™æ£€æŸ¥
    if (cred-&gt;user_ns != tcred-&gt;user_ns ||
        !kuid_has_mapping(cred-&gt;user_ns, tcred-&gt;suid)) {
        if (sig != SIGCONT || task_session(current) != task_session(t))
            return -EPERM;
    }

    // æ£€æŸ¥ CAP_KILL èƒ½åŠ›
    if (has_capability_noaudit(current, CAP_KILL))
        return 0;

    // æ™®é€šç”¨æˆ·åªèƒ½å‘è‡ªå·±çš„è¿›ç¨‹å‘é€ä¿¡å·
    if (uid_eq(cred-&gt;euid, tcred-&gt;suid) ||
        uid_eq(cred-&gt;euid, tcred-&gt;uid)  ||
        uid_eq(cred-&gt;uid,  tcred-&gt;suid) ||
        uid_eq(cred-&gt;uid,  tcred-&gt;uid))
        return 0;

    return -EPERM;
}

// kernel/signal.c
int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,
                enum pid_type type)
{
    int ret = 0;

    // å¿½ç•¥æ— æ•ˆä¿¡å·
    if (!valid_signal(sig) || sig &lt; 0)
        return -EINVAL;

    // æ£€æŸ¥æƒé™
    ret = check_kill_permission(sig, info, t);
    if (ret)
        return ret;

    // åˆå¹¶ç›¸åŒçš„å®æ—¶ä¿¡å·
    if (legacy_queue(sig, &amp;t-&gt;pending))
        return 0;

    // åˆ†é…ä¿¡å·é˜Ÿåˆ—é¡¹
    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, 0);
    if (q) {
        list_add_tail(&amp;q-&gt;list, &amp;t-&gt;pending.list);
        sigaddset(&amp;t-&gt;pending.signal, sig);
    }

    // å”¤é†’è¿›ç¨‹å¤„ç†ä¿¡å·
    signal_wake_up(t, sig == SIGKILL);
    return 0;
}</code></pre></div><h3 id="futex"><a class="doc-anchor" href="#futex">Â§</a>Futex</h3><h3 id="arceos-change"><a class="doc-anchor" href="#arceos-change">Â§</a>ArceOS change</h3><h4 id="axhal"><a class="doc-anchor" href="#axhal">Â§</a>axhal</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// arch/loongarch64
</span><span class="kw">pub use </span><span class="self">self</span>::context::{TaskContext, TrapFrame, GeneralRegisters};</code></pre></div>
<h3 id="questions"><a class="doc-anchor" href="#questions">Â§</a>Questions</h3>
<ul>
<li>Cç±»å‹ä½¿ç”¨æ··ä¹±ï¼Œè°ƒç”¨core::ffiï¼Œlinux_raw_sysï¼Œå¦‚æœè¦è°ƒç”¨areaos_posix_apiï¼Œè¿˜éœ€è¦è°ƒç”¨areos_posix_apiä¸­çš„ctypes</li>
<li>åŒæ­¥åŸè¯­ä½¿ç”¨æ··ä¹±ï¼Œaxsyncï¼Œspinï¼Œlock_api(axsignal)</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="entry/index.html" title="mod starry::entry">entry</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="mm/index.html" title="mod starry::mm">mm</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="syscall/index.html" title="mod starry::syscall">syscall</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.main.html" title="fn starry::main">main</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul></section></div></main></body></html>